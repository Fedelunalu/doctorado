<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Constelaciones - Experimentooctubre</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:wght@400;600&display=swap" rel="stylesheet">
  <style>
    /* --- Styles (preservo est√©tica original) --- */
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;overflow:hidden;font-family:"EB Garamond",serif;background:#0c0a09;color:#111}


    #stage{position:fixed;inset:0;display:grid;place-items:center}
    .aurora{position:absolute;inset:0;
      background: radial-gradient(1200px 800px at 20% 30%, #ffecd2 0%, transparent 60%),
                  radial-gradient(900px 700px at 80% 70%, #ffd1ff 0%, transparent 55%),
                  radial-gradient(900px 700px at 70% 20%, #d0f0ff 0%, transparent 55%),
                  radial-gradient(700px 600px at 30% 80%, #ffe2c7 0%, transparent 60%);
      filter: blur(40px) saturate(130%) contrast(105%);
      animation:hue 18s linear infinite alternate; opacity:.7; pointer-events:none}
    @keyframes hue{0%{transform:scale(1);filter:hue-rotate(0deg) blur(40px) saturate(130%) contrast(105%)}100%{transform:scale(1.05);filter:hue-rotate(40deg) blur(44px) saturate(140%) contrast(110%)}}
    #particles{position:absolute;inset:0;pointer-events:none;opacity:.85;mix-blend-mode:screen}
    /* Two network layers are in same container to preserve single visual area */
    #mynetwork{position:absolute;inset:0;box-shadow:inset 0 0 120px rgba(0,0,0,.6);cursor:grab}
    #mynetwork:active{cursor:grabbing}


    /* Overlay (glass) */
    #overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;padding:6vh 5vw;z-index:30;
      background: radial-gradient(1200px 800px at 50% 50%, rgba(255,255,255,.06) 0%, rgba(0,0,0,.65) 60%, rgba(0,0,0,.85) 100%);
      backdrop-filter: blur(8px) saturate(110%);animation:overlayIn 300ms ease forwards}
    @keyframes overlayIn{from{opacity:0}to{opacity:1}}
    .card{width:min(1100px,92vw);max-height:82vh;overflow:auto;padding:clamp(18px,3.2vw,36px);
      background:rgba(255,250,240,.12);border:1px solid rgba(217,166,115,.45);border-radius:20px;color:#faf4ec;box-shadow:0 10px 40px rgba(0,0,0,.55),inset 0 0 0 1px rgba(255,255,255,.06)}
    .title{font-size:clamp(28px,4.2vw,46px);color:#ffe7c7;margin-bottom:14px}
    .media{display:block;width:min(280px,60%);max-width:40vw;border-radius:14px;border:2px solid rgba(217,166,115,.55);box-shadow:0 8px 30px rgba(0,0,0,.35);margin:6px 0 18px 0}
    .text{font-size:clamp(18px,2.4vw,22px);line-height:1.65;color:#fff6eb;text-align:justify;white-space:pre-wrap}
    .close{position:sticky;top:0;float:right;transform:translate(10px,-10px);border:1px solid rgba(217,166,115,.6);background:rgba(255,248,240,.12);color:#ffe7c7;padding:8px 12px;border-radius:999px;cursor:pointer}
    .notes{margin-top:18px;padding-top:14px;border-top:1px solid rgba(255,224,196,.4);font-size:clamp(16px,2vw,20px);color:rgba(255,243,230,.92);line-height:1.6;white-space:pre-wrap}
    .hint{position:fixed;bottom:18px;left:18px;z-index:40;font-size:14px;color:rgba(255,236,214,.9);background:rgba(20,16,14,.45);border:1px solid rgba(217,166,115,.4);border-radius:999px;padding:8px 12px;pointer-events:none}


    /* Editor panel (kept) */
    .editor-panel{position:fixed;top:18px;right:18px;z-index:50;display:flex;flex-direction:column;gap:12px;padding:14px 18px;max-width:min(420px,92vw);background:rgba(18,14,12,.78);border:1px solid rgba(217,166,115,.4);border-radius:16px;box-shadow:0 12px 45px rgba(0,0,0,.4);backdrop-filter:blur(10px) saturate(120%)}
    .editor-panel h2{font-size:18px;margin-bottom:6px;color:#ffe7c7}
    .editor-panel label{display:block;font-size:14px;margin-bottom:4px;color:rgba(255,236,214,.85)}
    .editor-panel input,.editor-panel textarea,.editor-panel select{width:100%;padding:8px 10px;margin-bottom:10px;border-radius:10px;border:1px solid rgba(217,166,115,.35);background:rgba(255,248,240,.08);color:#fff6eb;resize:vertical}
    .editor-panel button{align-self:flex-start;padding:8px 14px;border-radius:999px;border:1px solid rgba(217,166,115,.55);background:rgba(255,248,240,.16);color:#ffe7c7;cursor:pointer}
    .editor-panel .panel-content{display:none;flex-direction:column;gap:14px;max-height:70vh;overflow-y:auto;padding-right:4px}
    .editor-panel .panel-content.active{display:flex}
    .editor-panel .message{font-size:13px;color:rgba(255,236,214,.9);margin-top:4px}


    /* small responsive tweaks */
    @media (max-width:720px){.card{padding:18px}}
  </style>
</head>
<body>
  <!-- Editor panel -->
  <div class="editor-panel" id="editorPanel" aria-label="Herramientas de edici√≥n">
    <button id="toggleEditor" aria-expanded="false">‚ú¶ Editar Red</button>
    <div class="panel-content" id="editorContent">
      <div class="section">
        <h2>Constelaci√≥n</h2>
        <label for="constellationSelect">Seleccionar constelaci√≥n</label>
        <select id="constellationSelect"></select>
        <div class="message">Crear nodo en la constelaci√≥n seleccionada.</div>
      </div>


      <div class="section">
        <h2>Editar nodo</h2>
        <p class="message" id="selectionMessage">Selecciona un nodo para editarlo.</p>
        <label for="nodeLabel">T√≠tulo</label>
        <input id="nodeLabel" type="text" placeholder="Nombre del nodo" />
        <label for="nodeInfo">Descripci√≥n</label>
        <textarea id="nodeInfo" placeholder="Texto del nodo"></textarea>
        <label for="nodeNotes">Notas (visible en ficha)</label>
        <textarea id="nodeNotes" placeholder="Notas adicionales"></textarea>
        <label for="nodeImage">Imagen (URL o base64)</label>
        <input id="nodeImage" type="text" placeholder="https://... o data:image/png;base64,..." />
        <label for="nodeAudio">Audio (URL)</label>
        <input id="nodeAudio" type="text" placeholder="https://..." />
        <label for="nodeVideo">Video (URL)</label>
        <input id="nodeVideo" type="text" placeholder="https://..." />
        <label for="nodeLink">Enlace externo</label>
        <input id="nodeLink" type="text" placeholder="https://..." />
        <label for="nodeColor">Color del nodo</label>
        <input id="nodeColor" type="color" value="#fff1e3" />
        <label><input id="nodePhysics" type="checkbox" /> Afectado por f√≠sica (inercia/tensi√≥n)</label>
        <label><input id="nodeFixed" type="checkbox" /> Bloqueado (no se mueve)</label>
        <div style="display:flex;gap:8px;">
          <button id="saveNode">Guardar cambios</button>
          <button id="deleteNode">Eliminar nodo</button>
        </div>
        <p class="message" id="nodeMessage"></p>
      </div>


      <div class="section">
        <h2>Conexiones</h2>
        <p class="message" id="connectionHelp">Modo: presion√° "Agregar conexi√≥n", luego clic en primer nodo ‚Üí luego en segundo.</p>
        <div style="display:flex;gap:8px;">
          <button id="addConnection">Agregar conexi√≥n</button>
          <button id="removeConnection">Quitar conexi√≥n</button>
        </div>
        <p class="message" id="connectionMessage"></p>
      </div>


      <div class="section">
        <h2>Nuevo nodo</h2>
        <label for="newNodeLabel">T√≠tulo</label>
        <input id="newNodeLabel" type="text" placeholder="Nombre del nuevo nodo" />
        <label for="newNodeInfo">Descripci√≥n</label>
        <textarea id="newNodeInfo" placeholder="Texto del nuevo nodo"></textarea>
        <label for="newNodeNotes">Notas (opcional)</label>
        <textarea id="newNodeNotes" placeholder="Notas para la ficha"></textarea>
        <label for="newNodeImage">Imagen (URL o base64)</label>
        <input id="newNodeImage" type="text" placeholder="https://... o data:image/png;base64,..." />
        <label for="newNodeAudio">Audio (URL)</label>
        <input id="newNodeAudio" type="text" placeholder="https://..." />
        <label for="newNodeVideo">Video (URL)</label>
        <input id="newNodeVideo" type="text" placeholder="https://..." />
        <label for="newNodeLink">Enlace externo</label>
        <input id="newNodeLink" type="text" placeholder="https://..." />
        <label for="newNodeColor">Color del nodo</label>
        <input id="newNodeColor" type="color" value="#fff1e3" />
        <label for="newNodePhysics"><input id="newNodePhysics" type="checkbox" /> Afectado por f√≠sica</label>
        <label for="newNodeFixed"><input id="newNodeFixed" type="checkbox" /> Bloqueado</label>
        <div style="display:flex;gap:8px;">
          <button id="createNode">Crear nodo</button>
          <button id="newConstellation">‚ûï Crear constelaci√≥n nueva</button>
        </div>
        <p class="message" id="createMessage"></p>
      </div>


      <div class="section">
        <h2>Guardar / Reset</h2>
        <div style="display:flex;gap:8px;">
          <button id="saveChanges">üíæ Guardar cambios</button>
          <button id="deleteConstellation">üóëÔ∏è Eliminar constelaci√≥n</button>
          <button id="exportJSON">Exportar JSON</button>
          <button id="importJSON">Importar JSON</button>
          <button id="resetBtn">Resetear</button>
        </div>
        <p class="message" id="storageMessage"></p>
      </div>
    </div>
  </div>


  <!-- Stage -->
  <div id="stage">
    <div class="aurora" aria-hidden="true"></div>
    <canvas id="particles"></canvas>
    <div id="mynetwork" role="application" aria-label="Visualizaci√≥n de red"></div>
    <div class="dim-overlay" id="dim"></div>
  </div>


  <!-- Overlay card -->
  <div id="overlay" aria-hidden="true">
    <article class="card" id="card">
  <button class="close" id="closeBtn" aria-label="Cerrar">‚úï</button>
  <h1 class="title" id="title"></h1>
  <div id="mediaContainer"></div>
  <div class="text" id="text"></div>


      <label style="margin-top:12px;color:#ffe7c7">Editar notas</label>
      <textarea id="notesInput" style="width:100%;min-height:120px;margin-top:8px;border-radius:10px;padding:10px;background:rgba(255,248,240,0.06);color:#fff6eb"></textarea>
      <div style="margin-top:10px;display:flex;gap:8px;">
        <button id="saveNotesOverlay" class="close">Guardar notas</button>
        <button id="closeOverlayBtn" class="close">Cerrar</button>
      </div>


      <div class="notes" id="notes" hidden></div>
    </article>
  </div>


  <div class="hint">clic en un nodo ¬∑ rueda para zoom ¬∑ arrastrar para mover</div>


  <script>
  document.addEventListener("DOMContentLoaded", async function() {
  // Declare connectMode at the top so it is available everywhere
  let connectMode = { active: false, remove: false, source: null };
    /*****************************************************************
     *  Constelaciones mejoradas (single vis.Network) - explicaci√≥n:
     *  - Usamos una sola vis.Network para evitar conflictos de clicks/overlay.
     *  - Cada nodo tiene propiedad `constellation` para agrupar.
     *  - Cuando se crea nodo en otra constelaci√≥n, lo ubicamos con un offset X grande
     *    para separarlo visualmente y evitar "atracci√≥n" inmediata.
     *  - Motor: barnesHut con par√°metros para movimiento "estelar".
     *  - Cada nodo puede tener `physics: true/false` y `fixed` para controlar inercia.
     *****************************************************************/


  // ---------- DATOS INICIALES (con constelaci√≥n y nodo de ejemplo) ----------
  const initialConfs = ["Constelaci√≥n Inicial"];
  let STORAGE_KEY = "experimentooctubre_graph_v1";

  // JSONBin.io configuraci√≥n para almacenamiento compartido
  const JSONBIN_BIN_ID = "68f7bee9ae596e708f221bcd";
  const JSONBIN_MASTER_KEY = "$2a$10$AoE2D4tCJtIc0kTx.0iL6OUrN6byqzt3tQLc9h9xS4VEztgkSj1ca";
  const JSONBIN_URL = `https://api.jsonbin.io/v3/b/${JSONBIN_BIN_ID}/latest`;


  let nodes_data =  [
    {
      "id": 601,
      "label": "Doctorado en Ciencias Sociales - UNCuyo",
      "info": "Constelaci√≥n base para proyectos, escrituras y exploraciones conceptuales de los/as doctorandos/as del Doctorado en Ciencias Sociales de la Universidad Nacional de Cuyo. Espacio colectivo para articular investigaciones, teor√≠as, pr√°cticas y afectos.",
      "notes": "Nodo central institucional y simb√≥lico.",
      "constellation": "Doctorado Ciencias Sociales UNCuyo",
      "physics": true,
      "fixed": false,
      "x": 500,
      "y": 80
    },
    {
      "id": 602,
      "label": "Mendoza",
      "info": "Contexto geogr√°fico, pol√≠tico y afectivo. Espacio donde se sit√∫an las pr√°cticas de investigaci√≥n, ense√±anza y militancia. Lugar de escritura y observaci√≥n, atravesado por tensiones territoriales, institucionales y sociales.",
      "notes": "Nodo territorial.",
      "constellation": "Doctorado Ciencias Sociales UNCuyo",
      "physics": true,
      "fixed": false,
      "x": 300,
      "y": 200
    },
    {
      "id": 603,
      "label": "Escritura",
      "info": "Pr√°ctica epistemol√≥gica, afectiva y pol√≠tica. La escritura como m√©todo, archivo y acto de pensamiento. Lugar de encuentro entre teor√≠a, experiencia y narraci√≥n.",
      "notes": "Nodo metodol√≥gico transversal.",
      "constellation": "Doctorado Ciencias Sociales UNCuyo",
      "physics": true,
      "fixed": false,
      "x": 700,
      "y": 200
    },
    {
      "id": 604,
      "label": "Conceptos",
      "info": "Campo donde se elaboran y tensionan las categor√≠as del pensamiento social: poder, cuerpo, territorio, memoria, g√©nero, lenguaje, vida. Los conceptos funcionan como nudos de disputa y creaci√≥n colectiva.",
      "notes": "Nodo te√≥rico central.",
      "constellation": "Doctorado Ciencias Sociales UNCuyo",
      "physics": true,
      "fixed": false,
      "x": 500,
      "y": 320
    },
    {
      "id": 605,
      "label": "Investigaci√≥n",
      "info": "Pr√°ctica situada y colectiva. Comprende estrategias metodol√≥gicas diversas: etnograf√≠a, archivo, an√°lisis de discurso, experimentaci√≥n, arte, acci√≥n pol√≠tica. En el doctorado, la investigaci√≥n se concibe como proceso y relaci√≥n.",
      "notes": "Nodo de praxis acad√©mica y pol√≠tica.",
      "constellation": "Doctorado Ciencias Sociales UNCuyo",
      "physics": true,
      "fixed": false,
      "x": 500,
      "y": 440
    },
    {
      "id": 606,
      "label": "Campo",
      "info": "El campo como territorio y como relaci√≥n. Espacio donde se entrelazan teor√≠a y experiencia, donde la investigaci√≥n se transforma. Puede ser una comunidad, una red, un archivo, una pr√°ctica est√©tica o una instituci√≥n.",
      "notes": "Nodo emp√≠rico y relacional.",
      "constellation": "Doctorado Ciencias Sociales UNCuyo",
      "physics": true,
      "fixed": false,
      "x": 300,
      "y": 560
    },
    {
      "id": 607,
      "label": "Teor√≠a",
      "info": "Espacio de elaboraci√≥n conceptual. Lugar donde las ideas se traman con los materiales emp√≠ricos. Incluye enfoques feministas, decoloniales, posthumanos, trans-travestis, marxistas, poscr√≠ticos, entre otros.",
      "notes": "Nodo de pensamiento articulador.",
      "constellation": "Doctorado Ciencias Sociales UNCuyo",
      "physics": true,
      "fixed": false,
      "x": 700,
      "y": 560
    },
    {
      "id": 608,
      "label": "Sujetos",
      "info": "Actores, cuerpos, experiencias y memorias que configuran el trabajo de investigaci√≥n. Sujetos colectivos, disidentes, invisibilizados o instituidos. El sujeto es tambi√©n quien investiga, situado en su propio entramado.",
      "notes": "Nodo pol√≠tico y ontol√≥gico.",
      "constellation": "Doctorado Ciencias Sociales UNCuyo",
      "physics": true,
      "fixed": false,
      "x": 500,
      "y": 680
    },
    {
      "id": 609,
      "label": "Archivo",
      "info": "Lugar de conservaci√≥n y disputa de la memoria. El archivo puede ser textual, audiovisual, corporal o afectivo. En el doctorado, los archivos se leen como espacios de resistencia y producci√≥n de conocimiento.",
      "notes": "Nodo material y simb√≥lico.",
      "constellation": "Doctorado Ciencias Sociales UNCuyo",
      "physics": true,
      "fixed": false,
      "x": 500,
      "y": 800
    },
    {
      "id": 610,
      "label": "Afectos / Temporalidades",
      "info": "La investigaci√≥n como experiencia afectiva. El tiempo del doctorado, sus pausas, intensidades, encuentros y transformaciones. Los afectos como fuerza que une lo individual y lo colectivo, el pensamiento y el cuerpo.",
      "notes": "Nodo sensible y existencial.",
      "constellation": "Doctorado Ciencias Sociales UNCuyo",
      "physics": true,
      "fixed": false,
      "x": 500,
      "y": 920
    }
  ];

  let edges_data =[
    { "from": 601, "to": 602, "id": "edge-601-602" },
    { "from": 601, "to": 603, "id": "edge-601-603" },
    { "from": 601, "to": 604, "id": "edge-601-604" },
    { "from": 604, "to": 605, "id": "edge-604-605" },
    { "from": 605, "to": 606, "id": "edge-605-606" },
    { "from": 605, "to": 607, "id": "edge-605-607" },
    { "from": 605, "to": 608, "id": "edge-605-608" },
    { "from": 608, "to": 609, "id": "edge-608-609" },
    { "from": 609, "to": 610, "id": "edge-609-610" },
    { "from": 602, "to": 605, "id": "edge-602-605" }
  ]



  // ---------- util: load saved state from JSONBin ----------
  async function loadState() {
    try {
      const response = await fetch(JSONBIN_URL, {
        method: 'GET',
        headers: {
          'X-Master-Key': JSONBIN_MASTER_KEY
        }
      });
      if (!response.ok) throw new Error('Failed to load from JSONBin');
      const data = await response.json();
      const record = data.record || null;
      return record ? { timestamp: record.timestamp || 0, nodes: record.nodes, edges: record.edges } : null;
    } catch (e) {
      console.warn("No se pudo leer estado desde JSONBin:", e);
      return null;
    }
  }


  async function saveState(payload) {
    const fullPayload = { timestamp: Date.now(), ...payload };
    try {
      const response = await fetch(`https://api.jsonbin.io/v3/b/${JSONBIN_BIN_ID}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          'X-Master-Key': JSONBIN_MASTER_KEY
        },
        body: JSON.stringify(fullPayload)
      });
      if (!response.ok) throw new Error('Failed to save to JSONBin');
      console.log("Estado guardado en JSONBin");
      return fullPayload.timestamp;
    } catch (e) {
      console.warn("No se pudo guardar estado en JSONBin:", e);
      return null;
    }
  }


  // ---------- datasets (vis) ----------
  // each node will have: id, label, info, notes, constellation, physics (true/false), fixed (object or false), x,y optional
  const saved = await loadState();
  const hasSavedNodes = Array.isArray(saved?.nodes) && saved.nodes.length > 0;
  const hasSavedEdges = Array.isArray(saved?.edges) && saved.edges.length > 0;

  if (hasSavedNodes) {
    // restore structure from saved (ensure defaults)
    nodes_data = saved.nodes.map(n => ({
      ...n,
      constellation: n.constellation || initialConfs[0],
      color: typeof n.color === "string" ? n.color : n.color?.background || "#fff1e3",
      physics: n.physics !== false
    }));
  } else {
    // enrich bundled nodes with defaults (physics true)
    nodes_data = nodes_data.map(n => ({
      ...n,
      constellation: n.constellation || initialConfs[0],
      color: typeof n.color === "string" ? n.color : n.color?.background || "#fff1e3",
      physics: n.physics !== false
    }));
  }

  if (hasSavedEdges) {
    edges_data = saved.edges;
  }


  const container = document.getElementById("mynetwork");
  const nodes = new vis.DataSet(nodes_data.map(n => {
    // convert fixed boolean to vis format
    const copy = { ...n, color: { background: n.color || "#fff1e3" } };
    if (copy.fixed === true) copy.fixed = { x: true, y: true };
    return copy;
  }));
  const edges = new vis.DataSet(edges_data);


  // ---------- funzione per posizionare initial nodes in groups ----------
  // If node has no x,y, place nodes of second constelation offset to right for separation.
  function ensureGroupSeparation() {
    // determine constellations present
    const confs = Array.from(new Set(nodes.get().map(n => n.constellation || initialConfs[0])));
    // assign bounding centers by index
    const width = window.innerWidth;
    const centers = {};
    confs.forEach((c, idx) => {
      // spread across horizontally
      const cx = (0.15 + 0.7 * (idx / Math.max(1, confs.length - 1))) * width;
      centers[c] = { x: cx, y: window.innerHeight / 2 };
    });
    // For each node without x,y set approximate around its constellation center with jitter
    nodes.get().forEach(n => {
      if (n.x == null || n.y == null) {
        const c = n.constellation || confs[0];
        const jitter = 180 + Math.random() * 120;
        const angle = Math.random() * Math.PI * 2;
        const x = centers[c].x + Math.cos(angle) * jitter;
        const y = centers[c].y + Math.sin(angle) * jitter;
        nodes.update({ id: n.id, x, y });
      }
    });
  }


  // Call now to set positions for newly created nodes if needed
  ensureGroupSeparation();


  // ---------- network options (barnesHut tuned) ----------
  const options = {
    autoResize: true,
    nodes: {
      shape: "dot",
      size: 18,
      font: { size: 18, color: "#fff6eb", face: "EB Garamond" },
      borderWidth: 2,
      shadow: { enabled: true, color: "rgba(255,180,120,.5)", size: 18, x: 0, y: 0 }
    },
    edges: {
      color: { color: "rgba(255,200,160,.85)", highlight: "#ffd6b3" },
      width: 2,
      smooth: { type: "continuous" },
      shadow: { enabled: true, color: "rgba(0,0,0,.35)", size: 8, x: 0, y: 0 }
    },
    physics: {
      enabled: true,
      solver: "barnesHut",
      barnesHut: {
        gravitationalConstant: -2000,   // negative to slightly repel globally (large magnitude -> stronger repulsion)
        centralGravity: 0.002,         // tiny central pull so groups don't drift off screen
        springLength: 220,
        springConstant: 0.02,
        damping: 0.28,
        avoidOverlap: 0.6
      },
      stabilization: { enabled: false }
    },
    interaction: {
      hover: true,
      tooltipDelay: 120,
      zoomView: true,
      dragView: true,
      dragNodes: true,
      multiselect: false,
      selectConnectedEdges: true
    },
    layout: { improvedLayout: false }
  };


  const network = new vis.Network(container, { nodes, edges }, options);


  /***********************
   * Persistence helpers *
   ***********************/
function persistAll() {
  const payload = {
    nodes: nodes.get().map(n => ({
      id: n.id, label: n.label, info: n.info, notes: n.notes || "",
      color: (typeof n.color === 'string' ? n.color : n.color?.background) || "#fff1e3",
      constellation: n.constellation || initialConfs[0],
      physics: (n.physics !== false),
      fixed: !!(n.fixed && (n.fixed.x === true || n.fixed === true)),
      x: (n.x != null ? n.x : undefined),
      y: (n.y != null ? n.y : undefined),
      image: n.image || "",
      audio: n.audio || "",
      video: n.video || "",
      link: n.link || ""
    })),
    edges: edges.get().map(e => ({ from: e.from, to: e.to, id: e.id }))
  };
  return saveState(payload);
}


  // Save on changes
  nodes.on("add", persistAll);
  nodes.on("update", persistAll);
  nodes.on("remove", persistAll);
  edges.on("add", persistAll);
  edges.on("remove", persistAll);


  // Also save after drag end positions
  network.on("dragEnd", params => {
    if (params.nodes && params.nodes.length) {
      const positions = network.getPositions(params.nodes);
      params.nodes.forEach(id => {
        const p = positions[id];
        // update node x,y to persist where it's left
        nodes.update({ id, x: p.x, y: p.y, color: { background: nodes.get(id).color?.background } });
      });
      persistAll();
    }
  });


  // ---------- Glow idle (gentle) ----------
  let pulse = 0;
  setInterval(() => {
    pulse = (pulse + 1) % 360;
    const factor = 18 + Math.sin(pulse * Math.PI / 180) * 1.6;
    network.setOptions({ nodes: { ...options.nodes, size: factor } });
  }, 90);


  // ---------- UI wiring ----------
  const toggleEditorBtn = document.getElementById("toggleEditor");
  const editorContent = document.getElementById("editorContent");
  const constellationSelect = document.getElementById("constellationSelect");


  // node edit fields
  const nodeLabelInput = document.getElementById("nodeLabel");
  const nodeInfoInput = document.getElementById("nodeInfo");
  const nodeNotesInput = document.getElementById("nodeNotes");
  const nodePhysicsInput = document.getElementById("nodePhysics");
  const nodeFixedInput = document.getElementById("nodeFixed");
  const selectionMessage = document.getElementById("selectionMessage");
  const saveNodeBtn = document.getElementById("saveNode");
  const deleteNodeBtn = document.getElementById("deleteNode");
  const nodeMessage = document.getElementById("nodeMessage");


  const nodeColorInput = document.getElementById("nodeColor");
  const nodeImageInput = document.getElementById("nodeImage");
  const nodeAudioInput = document.getElementById("nodeAudio");
  const nodeVideoInput = document.getElementById("nodeVideo");
  const nodeLinkInput = document.getElementById("nodeLink");


  const newNodeColorInput = document.getElementById("newNodeColor");
  const newNodeImageInput = document.getElementById("newNodeImage");
  const newNodeAudioInput = document.getElementById("newNodeAudio");
  const newNodeVideoInput = document.getElementById("newNodeVideo");
  const newNodeLinkInput = document.getElementById("newNodeLink");


  const mediaContainer = document.getElementById("mediaContainer");
 


  // create fields
  const newNodeLabelInput = document.getElementById("newNodeLabel");
  const newNodeInfoInput = document.getElementById("newNodeInfo");
  const newNodeNotesInput = document.getElementById("newNodeNotes");
  const newNodePhysics = document.getElementById("newNodePhysics");
  const newNodeFixed = document.getElementById("newNodeFixed");
  const createNodeBtn = document.getElementById("createNode");
  const newConstBtn = document.getElementById("newConstellation");
  const createMessage = document.getElementById("createMessage");


  // connection
  const addConnectionBtn = document.getElementById("addConnection");
  const removeConnectionBtn = document.getElementById("removeConnection");
  const connectionMessage = document.getElementById("connectionMessage");


  // overlay elements
  const overlay = document.getElementById("overlay");
  const titleEl = document.getElementById("title");
  const textEl = document.getElementById("text");
  const notesEl = document.getElementById("notes");
  const notesInput = document.getElementById("notesInput");
  const saveNotesOverlayBtn = document.getElementById("saveNotesOverlay");
  const closeOverlayBtn = document.getElementById("closeOverlayBtn");
  const closeBtn = document.getElementById("closeBtn");


  // export/import/reset
  const exportBtn = document.getElementById("exportJSON");
  const importBtn = document.getElementById("importJSON");
  const resetBtn = document.getElementById("resetBtn");
  const storageMessage = document.getElementById("storageMessage");


  // hint toggles
  toggleEditorBtn.addEventListener("click", () => {
    const active = editorContent.classList.toggle("active");
    toggleEditorBtn.setAttribute("aria-expanded", active ? "true" : "false");
  });


  // populate constellation select with existing groups from nodes and initial ones
  function refreshConstellationOptions() {
    const existing = new Set(nodes.get().map(n => n.constellation || initialConfs[0]));
    // ensure initialConfs present
    initialConfs.forEach(c => existing.add(c));
    // create options
    constellationSelect.innerHTML = "";
    Array.from(existing).forEach(c => {
      const o = document.createElement("option");
      o.value = c; o.textContent = c;
      constellationSelect.appendChild(o);
    });
  }
  refreshConstellationOptions();


  // selection state
  let activeNodeId = null;


function updateEditorForSelection(nodeId) {
  if (!nodeId) {
    selectionMessage.textContent = "Selecciona un nodo para editarlo.";
    nodeLabelInput.value = "";
    nodeInfoInput.value = "";
    nodeNotesInput.value = "";
    nodeColorInput.value = "#fff1e3";
    nodeImageInput.value = "";
    nodeAudioInput.value = "";
    nodeVideoInput.value = "";
    nodeLinkInput.value = "";
    nodePhysicsInput.checked = true;
    nodeFixedInput.checked = false;
    saveNodeBtn.disabled = true;
    deleteNodeBtn.disabled = true;
    return;
  }
  const n = nodes.get(nodeId);
  activeNodeId = nodeId;
  selectionMessage.textContent = `Editando nodo ID ${nodeId}`;
  nodeLabelInput.value = n.label || "";
  nodeInfoInput.value = n.info || "";
  nodeNotesInput.value = n.notes || "";
  nodeColorInput.value = n.color?.background || n.color || "#fff1e3";
  nodeImageInput.value = n.image || "";
  nodeAudioInput.value = n.audio || "";
  nodeVideoInput.value = n.video || "";
  nodeLinkInput.value = n.link || "";
  nodePhysicsInput.checked = (n.physics !== false);
  nodeFixedInput.checked = !!(n.fixed && (n.fixed.x === true || n.fixed === true));
  saveNodeBtn.disabled = false;
  deleteNodeBtn.disabled = false;
}


  network.on("selectNode", params => {
    const nodeId = params.nodes[0];
    updateEditorForSelection(nodeId);
    // open overlay
    if (!connectMode.active) {
      openOverlay(nodeId, params.pointer?.DOM);
    }
  });


saveNodeBtn.addEventListener("click", () => {
  if (!activeNodeId) return;
  const label = nodeLabelInput.value.trim();
  const info = nodeInfoInput.value.trim();
  if (!label || !info) { nodeMessage.textContent = "Completa t√≠tulo y descripci√≥n"; setTimeout(()=>nodeMessage.textContent="",2200); return; }
  const notes = nodeNotesInput.value.trim();
  const image = nodeImageInput.value.trim();
  const audio = nodeAudioInput.value.trim();
  const video = nodeVideoInput.value.trim();
  const link = nodeLinkInput.value.trim();
  const physics = nodePhysicsInput.checked;
  const fixedChecked = nodeFixedInput.checked;


  const color = nodeColorInput.value;
  const update = { id: activeNodeId, label, info, notes, color, image, audio, video, link, physics };
  if (fixedChecked) {
    // get position and fix there
    const pos = network.getPositions([activeNodeId])[activeNodeId];
    update.fixed = { x: true, y: true };
    update.x = pos.x; update.y = pos.y;
  } else {
    update.fixed = false;
    // leave x,y as they are (they'll be used by physics)
  }
  nodes.update(update);
  persistAll();
  nodeMessage.textContent = "Nodo guardado ‚úì";
  setTimeout(()=>nodeMessage.textContent="",1500);
});


  deleteNodeBtn.addEventListener("click", () => {
    if (!activeNodeId) return;
    const id = activeNodeId;
    nodes.remove({ id });
    // remove edges
    edges.get().forEach(e => { if (e.from === id || e.to === id) edges.remove(e.id); });
    persistAll();
    updateEditorForSelection(null);
  });


  // ---------- Overlay open/close and editing notes ----------
  let overlayNodeId = null;
function openOverlay(nodeId, pointer) {
  const n = nodes.get(nodeId);
  if (!n) return;
  overlayNodeId = nodeId;
  titleEl.textContent = n.label || "";
  textEl.textContent = n.info || "";
  notesInput.value = n.notes || "";
  notesEl.textContent = n.notes || "";
  notesEl.hidden = !n.notes;
  // Render media
  mediaContainer.innerHTML = "";
  if (n.image) {
    const img = document.createElement("img");
    img.src = n.image;
    img.alt = n.label || "Imagen";
    img.className = "media";
    img.style.maxWidth = "320px";
    img.style.marginBottom = "10px";
    mediaContainer.appendChild(img);
  }
  if (n.audio) {
    const audio = document.createElement("audio");
    audio.src = n.audio;
    audio.controls = true;
    audio.style.display = "block";
    audio.style.margin = "10px 0";
    mediaContainer.appendChild(audio);
  }
  if (n.video) {
    // YouTube embed support
    const ytMatch = n.video.match(/(?:youtu\.be\/|youtube\.com\/(?:embed\/|v\/|watch\?v=|shorts\/))([\w-]{11})/);
    if (ytMatch) {
      const iframe = document.createElement("iframe");
      iframe.src = `https://www.youtube.com/embed/${ytMatch[1]}`;
      iframe.width = "360";
      iframe.height = "215";
      iframe.allow = "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture";
      iframe.allowFullscreen = true;
      iframe.style.display = "block";
      iframe.style.maxWidth = "100%";
      iframe.style.margin = "10px 0";
      mediaContainer.appendChild(iframe);
    } else if (/^https?:\/\/.+\.(mp4|webm|ogg)(\?.*)?$/i.test(n.video)) {
      // Direct video file
      const video = document.createElement("video");
      video.src = n.video;
      video.controls = true;
      video.style.display = "block";
      video.style.maxWidth = "320px";
      video.style.margin = "10px 0";
      mediaContainer.appendChild(video);
    } else {
      // Fallback: show as link
      const a = document.createElement("a");
      a.href = n.video;
      a.textContent = "Ver video";
      a.target = "_blank";
      a.rel = "noopener noreferrer";
      a.style.display = "block";
      a.style.margin = "10px 0";
      a.style.color = "#ffd1ff";
      mediaContainer.appendChild(a);
    }
  }
  if (n.link) {
    const a = document.createElement("a");
    a.href = n.link;
    a.textContent = "Enlace externo";
    a.target = "_blank";
    a.rel = "noopener noreferrer";
    a.style.display = "block";
    a.style.margin = "10px 0";
    a.style.color = "#ffd1ff";
    mediaContainer.appendChild(a);
  }
  // set spotlight coords
  if (pointer) {
    document.getElementById("dim").style.setProperty("--x", pointer.x + "px");
    document.getElementById("dim").style.setProperty("--y", pointer.y + "px");
  }
  document.getElementById("dim").classList.add("show");
  overlay.style.display = "flex";
  overlay.setAttribute("aria-hidden","false");
  function closeOverlay() {
    overlay.style.display = "none";
    overlayNodeId = null;
    document.getElementById("dim").classList.remove("show");
  }
  saveNotesOverlayBtn.addEventListener("click", () => {
    if (!overlayNodeId) return;
    const newNotes = notesInput.value.trim();
    nodes.update({ id: overlayNodeId, notes: newNotes });
    persistAll();
    notesEl.textContent = newNotes;
    notesEl.hidden = !newNotes;
    saveNotesOverlayBtn.textContent = "Guardado ‚úì";
    setTimeout(()=> saveNotesOverlayBtn.textContent = "Guardar notas",800);
  });
  closeOverlayBtn.addEventListener("click", closeOverlay);
  closeBtn.addEventListener("click", closeOverlay);
}


  // ---------- Create new constellation button ----------
  newConstBtn.addEventListener("click", () => {
    let name = prompt("Nombre de la nueva constelaci√≥n:");
    if (!name) return;
    name = name.trim();
    if (!name) return;
    // Check if already exists (case-insensitive)
    const exists = Array.from(constellationSelect.options).some(opt => opt.value.toLowerCase() === name.toLowerCase());
    if (exists) {
      setMessage(createMessage, `La constelaci√≥n "${name}" ya existe.`);
      constellationSelect.value = name;
      constellationSelect.focus();
      return;
    }
    const opt = document.createElement("option");
    opt.value = name;
    opt.textContent = name;
    constellationSelect.appendChild(opt);
    constellationSelect.value = name;
    setMessage(createMessage, `Constelaci√≥n "${name}" creada ‚úì`);
    constellationSelect.focus();
  });


  // ---------- Create new node button ----------
  createNodeBtn.addEventListener("click", () => {
    const label = newNodeLabelInput.value.trim();
    const info = newNodeInfoInput.value.trim();
    if (!label || !info) { setMessage(createMessage, "Completa t√≠tulo y descripci√≥n"); return; }
    const notes = newNodeNotesInput.value.trim();
    const image = newNodeImageInput.value.trim();
    const audio = newNodeAudioInput.value.trim();
    const video = newNodeVideoInput.value.trim();
    const link = newNodeLinkInput.value.trim();
    const physics = newNodePhysics.checked;
    const fixed = newNodeFixed.checked;
    const constellation = constellationSelect.value || initialConfs[0];

    // find next id
    const existingIds = nodes.getIds();
    const nextId = existingIds.length ? Math.max(...existingIds) + 1 : 1;

  const color = newNodeColorInput.value || "#fff1e3";
  const newNode = {
    id: nextId,
    label,
    info,
    notes,
    color,
    image,
    audio,
    video,
    link,
    constellation,
    physics,
    fixed: fixed ? { x: true, y: true } : false
  };

  nodes.add(newNode);
  persistAll();
  refreshConstellationOptions();
  ensureGroupSeparation();
  setMessage(createMessage, `Nodo "${label}" creado ‚úì`);

  // clear inputs
  newNodeLabelInput.value = "";
  newNodeInfoInput.value = "";
  newNodeNotesInput.value = "";
  newNodeColorInput.value = "#fff1e3";
  newNodeImageInput.value = "";
  newNodeAudioInput.value = "";
  newNodeVideoInput.value = "";
  newNodeLinkInput.value = "";
  newNodePhysics.checked = true;
  newNodeFixed.checked = false;
  });
  // Accessibility: Enter key creates node if focused in new node fields
  [newNodeLabelInput, newNodeInfoInput, newNodeNotesInput].forEach(input => {
    input.addEventListener("keydown", e => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        createNodeBtn.click();
      }
    });
  });


  // Keyboard shortcut: Ctrl+E toggles editor panel
  document.addEventListener("keydown", e => {
    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "e") {
      e.preventDefault();
      toggleEditorBtn.click();
    }
  });


  // Improve focus ring for accessibility
  document.body.addEventListener('keydown', function(e) {
    if (e.key === 'Tab') {
      document.body.classList.add('user-is-tabbing');
    }
  });
  document.body.addEventListener('mousedown', function() {
    document.body.classList.remove('user-is-tabbing');
  });


  // Add focus style
  const style = document.createElement('style');
  style.textContent = `
    body.user-is-tabbing :focus {
      outline: 2.5px solid #ffd1ff !important;
      outline-offset: 2px;
    }
  `;
  document.head.appendChild(style);


  function setMessage(el, txt, timeout=2000) {
    el.textContent = txt;
    if (!txt) return;
    setTimeout(()=>{ if (el.textContent === txt) el.textContent = ""; }, timeout);
  }


  // ---------- Connection mode (click A then B) ----------


  addConnectionBtn.addEventListener("click", () => {
    connectMode = { active: true, remove: false, source: null };
    setMessage(connectionMessage, "Modo CONEXI√ìN: clic en primer nodo ‚Üí clic en segundo nodo", 5000);
  });


  removeConnectionBtn.addEventListener("click", () => {
    connectMode = { active: true, remove: true, source: null };
    setMessage(connectionMessage, "Modo BORRAR CONEXI√ìN: clic en primer nodo ‚Üí clic en segundo nodo", 5000);
  });


  // intercept clicks to implement connectMode, otherwise default to opening overlay
  network.on("click", params => {
    // if click on node(s) and connectMode active, handle it
    if (connectMode.active && params.nodes && params.nodes.length) {
      const clicked = params.nodes[0];
      if (!connectMode.source) {
        connectMode.source = clicked;
        setMessage(connectionMessage, `Origen seleccionado: ${clicked}. Ahora clic en destino.`, 3000);
      } else {
        const src = connectMode.source;
        const dst = clicked;
        if (src === dst) {
          setMessage(connectionMessage, "Origen y destino iguales. Cancelando modo conexi√≥n.", 1800);
          connectMode = { active: false, remove: false, source: null };
        } else {
          // ensure same constellation? allow cross-constellation connections if wanted.
          if (connectMode.remove) {
            const existing = edges.get({ filter: e => ( (e.from==src && e.to==dst) || (e.from==dst && e.to==src) ) });
            if (!existing.length) setMessage(connectionMessage, "No existe esa conexi√≥n.",1500);
            else { existing.forEach(e=>edges.remove(e.id)); setMessage(connectionMessage,"Conexi√≥n eliminada",1200); }
          } else {
            const existing = edges.get({ filter: e => ( (e.from==src && e.to==dst) || (e.from==dst && e.to==src) ) });
            if (existing.length) setMessage(connectionMessage, "Ya existe esa conexi√≥n.",1400);
            else { edges.add({ from: src, to: dst }); setMessage(connectionMessage, "Conexi√≥n creada ‚úì",1200); }
          }
          connectMode = { active: false, remove: false, source: null };
          persistAll();
        }
      }
      return; // stop further handling (avoid overlay focus)
    }


    // else -- if it's a node click open overlay (we already have network.on('selectNode') opening overlay)
    // default behavior handled elsewhere
  });


  // ---------- prevent auto-zoom loops ----------
  // We avoid calling network.focus or network.fit when creating nodes or edges.
  // Only use gentle fit on initial load once.
  let initialFitted = false;
  if (!initialFitted) {
    setTimeout(()=>{ try { network.moveTo({scale:1}); network.fit({animation:{duration:600}}); } catch(e){} }, 500);
    initialFitted = true;
  }


  // ---------- Export / Import / Reset ----------
  exportBtn.addEventListener("click", () => {
    const payload = {
      nodes: nodes.get().map(n => ({
        id: n.id, label: n.label, info: n.info, notes: n.notes || "",
        color: n.color?.background || "#fff1e3",
        constellation: n.constellation || initialConfs[0],
        physics: (n.physics !== false),
        fixed: !!(n.fixed && (n.fixed.x === true || n.fixed === true)),
        x: (n.x != null ? n.x : undefined),
        y: (n.y != null ? n.y : undefined),
        image: n.image || "",
        audio: n.audio || "",
        video: n.video || "",
        link: n.link || ""
      })),
      edges: edges.get().map(e => ({ from: e.from, to: e.to, id: e.id }))
    };
    const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a"); a.href = url; a.download = "constelaciones_export.json"; a.click();
    URL.revokeObjectURL(url);
  });


  importBtn.addEventListener("click", () => {
    const txt = prompt("Pegar JSON exportado:");
    if (!txt) return;
    let parsed;
    try {
      parsed = JSON.parse(txt);
    } catch (e) {
      setMessage(storageMessage, "Error parseando JSON", 2400);
      return;
    }
    if (!parsed || !Array.isArray(parsed.nodes) || !Array.isArray(parsed.edges)) {
      setMessage(storageMessage, "JSON inv√°lido", 2400);
      return;
    }


    const modeInput = prompt("Escrib√≠ 'agregar' para sumar al mapa actual o 'reemplazar' para sobrescribir. (Cancelar para abortar)");
    if (modeInput === null) {
      setMessage(storageMessage, "Importaci√≥n cancelada", 1600);
      return;
    }
    const mode = modeInput.trim().toLowerCase();
    if (mode !== "agregar" && mode !== "reemplazar") {
      setMessage(storageMessage, "Modo inv√°lido. Us√° 'agregar' o 'reemplazar'.", 2400);
      return;
    }


    const normNodes = parsed.nodes.map(n => {
      const copy = { ...n };
      if (copy.fixed === true) copy.fixed = { x: true, y: true };
      return copy;
    });
    const normEdges = parsed.edges.map(e => ({ ...e }));


    if (mode === "reemplazar") {
      nodes.clear();
      edges.clear();
      nodes.add(normNodes);
      edges.add(normEdges);
      persistAll();
      refreshConstellationOptions();
      ensureGroupSeparation();
      setMessage(storageMessage, "Importaci√≥n (reemplazo) OK", 2200);
      return;
    }


    const existingNodeIds = new Set(nodes.getIds());
    const usedNodeIds = new Set(existingNodeIds);
    const idMap = new Map();


    function makeUniqueId(originalId) {
      let base = originalId;
      if (base == null || base === "") {
        base = `node_${Date.now()}_${Math.random().toString(36).slice(2, 7)}`;
      }
      if (!usedNodeIds.has(base)) {
        usedNodeIds.add(base);
        return base;
      }
      const sanitized = String(base).replace(/\s+/g, "_");
      let counter = 1;
      let candidate = sanitized;
      while (usedNodeIds.has(candidate)) {
        candidate = `${sanitized}_${counter}`;
        counter += 1;
      }
      usedNodeIds.add(candidate);
      return candidate;
    }


    const nodesToAdd = normNodes.map(node => {
      let desiredId = node.id;
      if (desiredId == null || desiredId === "" || usedNodeIds.has(desiredId)) {
        desiredId = makeUniqueId(desiredId);
      } else {
        usedNodeIds.add(desiredId);
      }
      if (node.id != null && node.id !== desiredId) {
        idMap.set(node.id, desiredId);
      }
      return { ...node, id: desiredId };
    });


    const edgesToAdd = normEdges.map(edge => {
      const mappedFrom = idMap.has(edge.from) ? idMap.get(edge.from) : edge.from;
      const mappedTo = idMap.has(edge.to) ? idMap.get(edge.to) : edge.to;
      const copy = { ...edge, from: mappedFrom, to: mappedTo };
      delete copy.id;
      return copy;
    });


    nodes.add(nodesToAdd);
    edges.add(edgesToAdd);
    persistAll();
    refreshConstellationOptions();
    ensureGroupSeparation();
    setMessage(storageMessage, `Importaci√≥n agregada (${nodesToAdd.length} nodos, ${edgesToAdd.length} enlaces)`, 2800);
  });


  resetBtn.addEventListener("click", () => {
    if (!confirm("¬øBorrar todo y volver al estado inicial?")) return;
    localStorage.removeItem(STORAGE_KEY);
    location.reload();
  });


  // ---------- Save Changes button ----------
  const saveChangesBtn = document.getElementById("saveChanges");
  saveChangesBtn.addEventListener("click", () => {
    persistAll();
    setMessage(storageMessage, "Cambios guardados ‚úì", 2000);
  });


  // ---------- Delete Constellation button ----------
  const deleteConstellationBtn = document.getElementById("deleteConstellation");
  deleteConstellationBtn.addEventListener("click", () => {
    const constellations = Array.from(new Set(nodes.get().map(n => n.constellation || initialConfs[0])));
    if (constellations.length <= 1) {
      setMessage(storageMessage, "No hay constelaciones para eliminar", 2000);
      return;
    }
    const toDelete = prompt("Nombre de la constelaci√≥n a eliminar:");
    if (!toDelete) return;
    if (!constellations.includes(toDelete)) {
      setMessage(storageMessage, "Constelaci√≥n no encontrada", 2000);
      return;
    }
    if (!confirm(`¬øEliminar constelaci√≥n "${toDelete}" y todos sus nodos?`)) return;
    // Remove nodes in that constellation
    const nodesToRemove = nodes.get().filter(n => n.constellation === toDelete).map(n => n.id);
    nodes.remove(nodesToRemove);
    // Remove edges connected to those nodes
    const edgesToRemove = edges.get().filter(e => nodesToRemove.includes(e.from) || nodesToRemove.includes(e.to)).map(e => e.id);
    edges.remove(edgesToRemove);
    persistAll();
    refreshConstellationOptions();
    ensureGroupSeparation();
    setMessage(storageMessage, `Constelaci√≥n "${toDelete}" eliminada`, 2000);
  });


  // ---------- utility: clicking empty area deselects and closes overlay ----------
  // (No handler needed: vis.js already handles background clicks appropriately)


  // ---------- small particle background (kept original) ----------
  const canvas = document.getElementById("particles");
  const ctx = canvas.getContext("2d", { alpha: true });
  let DPR = Math.min(window.devicePixelRatio || 1, 2);
  function resizeCanvas() {
    DPR = Math.min(window.devicePixelRatio || 1, 2);
    canvas.width = Math.floor(innerWidth * DPR);
    canvas.height = Math.floor(innerHeight * DPR);
    canvas.style.width = innerWidth + "px";
    canvas.style.height = innerHeight + "px";
  }
  resizeCanvas();
  window.addEventListener("resize", resizeCanvas);


  const N = 90;
  const parts = new Array(N).fill(0).map(() => ({
    x: Math.random() * canvas.width,
    y: Math.random() * canvas.height,
    vx: (Math.random() - 0.5) * 0.14 * DPR,
    vy: (Math.random() - 0.5) * 0.14 * DPR,
    r: (Math.random() * 1.2 + 0.6) * DPR
  }));


  function tick() {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    for (let i=0;i<N;i++){
      const a = parts[i];
      a.x += a.vx; a.y += a.vy;
      if (a.x < 0 || a.x > canvas.width) a.vx *= -1;
      if (a.y < 0 || a.y > canvas.height) a.vy *= -1;
      ctx.beginPath(); ctx.arc(a.x, a.y, a.r, 0, Math.PI*2);
      ctx.fillStyle = "rgba(255,230,210,0.55)"; ctx.fill();
      for (let j=i+1;j<N;j++){
        const b = parts[j];
        const dx = a.x-b.x, dy = a.y-b.y;
        const d2 = dx*dx+dy*dy; const max = 140*DPR;
        if (d2 < max*max) {
          const alpha = 1 - Math.sqrt(d2)/max;
          ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y);
          ctx.lineWidth = 0.8 * DPR; ctx.strokeStyle = `rgba(255,210,180,${0.12*alpha})`; ctx.stroke();
        }
      }
    }
    requestAnimationFrame(tick);
  }
  tick();


  // ---------- keyboard support: Esc to cancel connect mode and close overlay ----------
  document.addEventListener("keydown", e=> {
    if (e.key === "Escape") {
      connectMode = { active:false, remove:false, source:null };
      closeOverlay();
    }
  });


  // ---------- On first load, ensure constellations menu reflects groups present ----------
  refreshConstellationOptions();


  let localTimestamp = 0;
  let isSyncing = false;

  // Initialize localTimestamp from saved state
  if (hasSavedNodes) {
    localTimestamp = saved.timestamp || 0;
  }

  // ---------- Collaborative editing: periodic sync ----------
  // Poll for changes every 5 minutes to enable collaborative editing (reduced frequency to avoid constant updates)
  setInterval(async () => {
    if (isSyncing) return; // Prevent overlapping syncs
    isSyncing = true;
    try {
      const latest = await loadState();
      if (!latest || !latest.nodes || !latest.edges || latest.timestamp <= localTimestamp) {
        isSyncing = false;
        return;
      }

      const remoteNodes = latest.nodes;
      const remoteEdges = latest.edges;
      const currentNodeIds = new Set(nodes.getIds());
      const currentEdgeIds = new Set(edges.getIds());

      let updated = false;

      // Merge nodes: add new, update existing, don't remove local
      remoteNodes.forEach(remoteNode => {
        const copy = { ...remoteNode, color: { background: remoteNode.color || "#fff1e3" } };
        if (copy.fixed === true) copy.fixed = { x: true, y: true };
        if (!currentNodeIds.has(remoteNode.id)) {
          // Add new node
          nodes.add(copy);
          updated = true;
        } else {
          // Update existing node
          nodes.update(copy);
          updated = true;
        }
      });

      // Merge edges: add new, don't remove local
      remoteEdges.forEach(remoteEdge => {
        if (!currentEdgeIds.has(remoteEdge.id)) {
          edges.add(remoteEdge);
          updated = true;
        }
      });

      if (updated) {
        localTimestamp = latest.timestamp;
        refreshConstellationOptions();
        ensureGroupSeparation();
        console.log("Sincronizado con cambios colaborativos (merge)");
        // Reset selection if node was updated/removed (though we don't remove)
        if (activeNodeId && !nodes.get(activeNodeId)) {
          updateEditorForSelection(null);
        }
      }
    } catch (e) {
      console.warn("Error en sincronizaci√≥n colaborativa:", e);
    } finally {
      isSyncing = false;
    }
  }, 300000); // Sync every 5 minutes


  // ---------- Manual sync button ----------
  // Add a sync button to the editor panel
  const syncBtn = document.createElement("button");
  syncBtn.textContent = "üîÑ Sincronizar ahora";
  syncBtn.style.marginTop = "10px";
  syncBtn.addEventListener("click", async () => {
    syncBtn.textContent = "Sincronizando...";
    syncBtn.disabled = true;
    try {
      const latest = await loadState();
      if (latest && latest.nodes && latest.edges) {
        // Capture current state before syncing
        const currentNodes = nodes.get();
        const currentEdges = edges.get();
        const currentNodeIds = new Set(currentNodes.map(n => n.id));
        const currentEdgeIds = new Set(currentEdges.map(e => e.id));

        nodes.clear();
        edges.clear();
        nodes.add(latest.nodes.map(n => {
          const copy = { ...n, color: { background: n.color || "#fff1e3" } };
          if (copy.fixed === true) copy.fixed = { x: true, y: true };
          return copy;
        }));
        edges.add(latest.edges);
        refreshConstellationOptions();
        ensureGroupSeparation();
        updateEditorForSelection(null); // Reset selection

        // Identify additions
        const newNodes = latest.nodes.filter(n => !currentNodeIds.has(n.id));
        const newEdges = latest.edges.filter(e => !currentEdgeIds.has(e.id));
        const addedNodeLabels = newNodes.map(n => n.label).slice(0, 5); // Limit to first 5 for brevity
        const addedEdgeCount = newEdges.length;

        // Build message with references
        let syncMessage = "Sincronizado ‚úì";
        if (addedNodeLabels.length > 0 || addedEdgeCount > 0) {
          const parts = [];
          if (addedNodeLabels.length > 0) {
            parts.push(`Nodos: ${addedNodeLabels.join(', ')}${newNodes.length > 5 ? '...' : ''}`);
          }
          if (addedEdgeCount > 0) {
            parts.push(`Enlaces: ${addedEdgeCount}`);
          }
          syncMessage = `Sincronizado: +${parts.join(', +')}`;
        }
        setMessage(storageMessage, syncMessage, 4000); // Longer timeout for detailed message
      } else {
        setMessage(storageMessage, "No hay datos para sincronizar", 2000);
      }
    } catch (e) {
      setMessage(storageMessage, "Error al sincronizar", 2000);
    }
    syncBtn.textContent = "üîÑ Sincronizar ahora";
    syncBtn.disabled = false;
  });
  document.querySelector(".editor-panel .section:last-child").appendChild(syncBtn);


  // done
  console.log("Constelaciones cargadas. Modo colaborativo activado.");
});// <-- This closes the DOMContentLoaded function
</script>
</body>
</html>

